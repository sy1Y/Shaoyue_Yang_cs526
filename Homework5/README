#How to run Q1: just click run
#How to run Q2: run it using the following command in the Windows terminal (cmd): python P2.py < "vowel_input1.txt"
#How to run Q3: run it using the following command in the Windows terminal (cmd): python P3_longest.py < "longest_seq1.txt"

#Q1 Algorithm Explanation:
Firstly, I defined the Node class with its init, and way it dispaly(combine two childern of one node with dash, calculate
how long the line needed for connect parent and children, how fit the dash in different lines and so on). The purpose of
the Node class is to take an input value and output a node containing that value, whose left and right children are 
initialized to None. If the node has no children, the value is returned as a string. If the node has children, a binary
search tree (BST) is returned.
Then I defined the BST class. 
For add_node(), start traversing from the root node. If the tree is empty, the new node becomes the root node. If not
empty, compare the node values: if smaller, search the left subtree; if larger, search the right subtree. Insert the new 
node when an empty position is found. Return failure if the value already exists.
For delete_node(), first, search theode and its parent node. If there are no child nodes, delete it directly; if there is
only one child node, replace it with that child node; if there are two child nodes, find the smallest node in the right 
subtree (inorder successor) to replace the target node value, and then delete that smallest node.
For FindNode(), begin binary search from the root node. Compare the target value with the current node's value: if equal,
return the current node; if smaller, search the left subtree; if larger, search the right subtree. Continue until the 
target is found or a null node is reached.
For print_tree(), print 'The tree is empty' for empty tree, else using the display method in Node class. 
In the test part, namely, def main(), values ​​to be added to the BST are generated using random numbers, the BST is 
created using add_node(), and then each method of the BST is tested.

#Q2 Algorithm Explanation:

#Q3 Algorithm Explanation:
This algorithm finds the longest strictly increasing sequence where elements alternate between two input arrays while 
preserving their original order. The solution uses a dynamic programming approach with two complementary DP arrays: 
one for sequences ending with elements from array A, and another for sequences ending with elements from array B. Each
track maintains both the maximum sequence length and parent pointers for reconstruction. 
For every element pair between the two arrays, the algorithm checks if they can extend each other's sequences while 
maintaining strict increasing order and alternation. Parent pointers track the sequence path, enabling efficient 
backtracking to construct the final solution once the maximum length is found.
