#How to run Q1: just click run
#Q1 Algorithm Explanation:
Firstly, I defined the Node class with its init, and way it dispaly(combine two childern of one node with dash, calculate
how long the line needed for connect parent and children, how fit the dash in different lines and so on). The purpose of
the Node class is to take an input value and output a node containing that value, whose left and right children are 
initialized to None. If the node has no children, the value is returned as a string. If the node has children, a binary
search tree (BST) is returned.

Then I defined the BST class. 

For add_node(), start traversing from the root node. If the tree is empty, the new node becomes the root node. If not
empty, compare the node values: if smaller, search the left subtree; if larger, search the right subtree. Insert the new 
node when an empty position is found. Return failure if the value already exists.
For delete_node(), first, search theode and its parent node. If there are no child nodes, delete it directly; if there is
only one child node, replace it with that child node; if there are two child nodes, find the smallest node in the right 
subtree (inorder successor) to replace the target node value, and then delete that smallest node.
For FindNode(), begin binary search from the root node. Compare the target value with the current node's value: if equal,
return the current node; if smaller, search the left subtree; if larger, search the right subtree. Continue until the 
target is found or a null node is reached.
For print_tree(), print 'The tree is empty' for empty tree, else using the display method in Node class. 
In the test part, namely, def main(), values ​​to be added to the BST are generated using random numbers, the BST is 
created using add_node(), and then each method of the BST is tested.
